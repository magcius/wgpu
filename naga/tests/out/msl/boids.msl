// language: metal1.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size1;
    uint size2;
};

struct Particle {
    metal::float2 pos;
    metal::float2 vel;
};
struct SimParams {
    float deltaT;
    float rule1Distance;
    float rule2Distance;
    float rule3Distance;
    float rule1Scale;
    float rule2Scale;
    float rule3Scale;
};
typedef Particle type_3[1];
struct Particles {
    type_3 particles;
};
constant uint NUM_PARTICLES = 1500u;

struct main_Input {
};
kernel void main_(
  metal::uint3 global_invocation_id [[thread_position_in_grid]]
, constant SimParams& params [[buffer(0)]]
, device Particles const& particlesSrc [[buffer(1)]]
, device Particles& particlesDst [[buffer(2)]]
, constant _mslBufferSizes& _buffer_sizes [[buffer(3)]]
) {
    metal::float2 vPos = {};
    metal::float2 vVel = {};
    metal::float2 cMass = metal::float2(0.0, 0.0);
    metal::float2 cVel = metal::float2(0.0, 0.0);
    metal::float2 colVel = metal::float2(0.0, 0.0);
    int cMassCount = 0;
    int cVelCount = 0;
    metal::float2 pos = {};
    metal::float2 vel = {};
    uint i = 0u;
    uint index = global_invocation_id.x;
    if (index >= NUM_PARTICLES) {
        return;
    }
    vPos = particlesSrc.particles[index].pos;
    vVel = particlesSrc.particles[index].vel;
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            i = i + 1u;
        }
        loop_init = false;
        if (i >= NUM_PARTICLES) {
            break;
        }
        if (i == index) {
            continue;
        }
        pos = particlesSrc.particles[i].pos;
        vel = particlesSrc.particles[i].vel;
        if (metal::distance(pos, vPos) < params.rule1Distance) {
            cMass = cMass + pos;
            cMassCount = cMassCount + 1;
        }
        if (metal::distance(pos, vPos) < params.rule2Distance) {
            colVel = colVel - (pos - vPos);
        }
        if (metal::distance(pos, vPos) < params.rule3Distance) {
            cVel = cVel + vel;
            cVelCount = cVelCount + 1;
        }
#define LOOP_IS_BOUNDED { volatile bool unpredictable_break_from_loop = false; if (unpredictable_break_from_loop) break; }
        LOOP_IS_BOUNDED
    }
    if (cMassCount > 0) {
        cMass = (cMass / metal::float2(static_cast<float>(cMassCount))) - vPos;
    }
    if (cVelCount > 0) {
        cVel = cVel / metal::float2(static_cast<float>(cVelCount));
    }
    vVel = ((vVel + (cMass * params.rule1Scale)) + (colVel * params.rule2Scale)) + (cVel * params.rule3Scale);
    vVel = metal::normalize(vVel) * metal::clamp(metal::length(vVel), 0.0, 0.1);
    vPos = vPos + (vVel * params.deltaT);
    if (vPos.x < -1.0) {
        vPos.x = 1.0;
    }
    if (vPos.x > 1.0) {
        vPos.x = -1.0;
    }
    if (vPos.y < -1.0) {
        vPos.y = 1.0;
    }
    if (vPos.y > 1.0) {
        vPos.y = -1.0;
    }
    particlesDst.particles[index].pos = vPos;
    particlesDst.particles[index].vel = vVel;
    return;
}
