fn main_1() {
    var a: vec4<f32> = vec4(1f);
    var b: vec4<f32> = vec4(2f);
    var m: mat4x4<f32>;
    var i: i32 = 5i;
    var ceilOut: vec4<f32>;
    var roundOut: vec4<f32>;
    var floorOut: vec4<f32>;
    var fractOut: vec4<f32>;
    var truncOut: vec4<f32>;
    var sinOut: vec4<f32>;
    var absOut: vec4<f32>;
    var sqrtOut: vec4<f32>;
    var inversesqrtOut: vec4<f32>;
    var expOut: vec4<f32>;
    var exp2Out: vec4<f32>;
    var signOut: vec4<f32>;
    var transposeOut: mat4x4<f32>;
    var normalizeOut: vec4<f32>;
    var sinhOut: vec4<f32>;
    var cosOut: vec4<f32>;
    var coshOut: vec4<f32>;
    var tanOut: vec4<f32>;
    var tanhOut: vec4<f32>;
    var acosOut: vec4<f32>;
    var asinOut: vec4<f32>;
    var logOut: vec4<f32>;
    var log2Out: vec4<f32>;
    var lengthOut: f32;
    var determinantOut: f32;
    var bitCountOut: i32;
    var bitfieldReverseOut: i32;
    var atanOut: f32;
    var atan2Out: f32;
    var modOut: f32;
    var powOut: vec4<f32>;
    var dotOut: f32;
    var maxOut: vec4<f32>;
    var minOut: vec4<f32>;
    var reflectOut: vec4<f32>;
    var crossOut: vec3<f32>;
    var distanceOut: f32;
    var stepOut: vec4<f32>;
    var ldexpOut: f32;
    var rad: vec4<f32>;
    var deg: f32;
    var smoothStepScalar: f32;
    var smoothStepVector: vec4<f32>;
    var smoothStepMixed: vec4<f32>;

    let _e6 = a;
    let _e7 = b;
    let _e8 = a;
    let _e9 = b;
    m = mat4x4<f32>(vec4<f32>(_e6.x, _e6.y, _e6.z, _e6.w), vec4<f32>(_e7.x, _e7.y, _e7.z, _e7.w), vec4<f32>(_e8.x, _e8.y, _e8.z, _e8.w), vec4<f32>(_e9.x, _e9.y, _e9.z, _e9.w));
    ceilOut = ceil(a);
    roundOut = round(a);
    floorOut = floor(a);
    fractOut = fract(a);
    truncOut = trunc(a);
    sinOut = sin(a);
    absOut = abs(a);
    sqrtOut = sqrt(a);
    inversesqrtOut = inverseSqrt(a);
    expOut = exp(a);
    exp2Out = exp2(a);
    signOut = sign(a);
    transposeOut = transpose(m);
    normalizeOut = normalize(a);
    sinhOut = sinh(a);
    cosOut = cos(a);
    coshOut = cosh(a);
    tanOut = tan(a);
    tanhOut = tanh(a);
    acosOut = acos(a);
    asinOut = asin(a);
    logOut = log(a);
    log2Out = log2(a);
    lengthOut = length(a);
    determinantOut = determinant(m);
    bitCountOut = countOneBits(i);
    bitfieldReverseOut = reverseBits(i);
    atanOut = atan(a.x);
    atan2Out = atan2(a.x, a.y);
    modOut = (a.x - (floor((a.x / b.x)) * b.x));
    powOut = pow(a, b);
    dotOut = dot(a, b);
    maxOut = max(a, b);
    minOut = min(a, b);
    reflectOut = reflect(a, b);
    crossOut = cross(a.xyz, b.xyz);
    distanceOut = distance(a, b);
    stepOut = step(a, b);
    ldexpOut = ldexp(a.x, i);
    rad = radians(a);
    deg = degrees(a.x);
    smoothStepScalar = smoothstep(0f, 1f, 0.5f);
    smoothStepVector = smoothstep(vec4(0f), vec4(1f), vec4(0.5f));
    smoothStepMixed = smoothstep(vec4(0f), vec4(1f), vec4(0.5f));
    return;
}

@fragment 
fn main() {
    main_1();
    return;
}
